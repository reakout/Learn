# `RUST`权威指南读书笔记

[TOC]

## Char3 通用编程概念

### 变量与可变性

#### 变量

用let声明的变量默认是不可变的，如以下会报错

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

如果想要改变值的话，需要声明时加上`mut`

`let mut x = 5;`

#### 常量

`const`关键字，不允许使用`mut`也不能修改值，只能设置为**常量表达式**，且**类型必须注明**，也不能使用函数调用结果或者运行时结果

常量命名应该用全大写加下划线，如下:

`const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;`

#### 遮蔽

可以用`let`重复使用相同的变量名来遮蔽变量，如

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```

外层作用域里遮蔽一次，内层作用域里遮蔽一次，但传不出来，所以两次输出结果应该是12和6

遮蔽可以完成一些值的转换，但完成之后还是不可变的

与`mut`的区别，用`let`本质是再创建了一个新的变量，但是重复使用了相同的名称，因此用`let`遮蔽可以同名换类型，但`mut`不允许更改类型，如

```rust
fn main() {
    let spaces = "   ";
    let spaces = spaces.len();
}
```

```rust
fn main() {
    let mut spaces = "   ";
    spaces = spaces.len();
}
```

第一个ok第二个报错。

### 数据类型

`rust`是静态类型语言，即需要在编译器而非运行时得到所有的变量类型

#### 标量类型

表示单个值的类型（scalar），在`rust`中有整型、浮点、布尔和字符四种

 ##### 整型

| 长度   | 有符号类型 | 无符号类型 |
| ------ | ---------- | ---------- |
| 8 位   | `i8`       | `u8`       |
| 16 位  | `i16`      | `u16`      |
| 32 位  | `i32`      | `u32`      |
| 64 位  | `i64`      | `u64`      |
| 128 位 | `i128`     | `u128`     |
| arch   | `isize`    | `usize`    |

`isize`和`usize`取决于系统架构，64位则是64位，32位则32位

可能属于多个数字类型的数字字面值允许使用类型后缀指定类型，如`58u8`。数字字面值还可以用`_`作为不影响大小和正确性的可视分割符，如`1_000`

不同进制还可以直接用于字面量赋值

| 数字字面量         | 示例          |
| ------------------ | ------------- |
| 十进制             | `98_222`      |
| 十六进制           | `0xff`        |
| 八进制             | `0o77`        |
| 二进制             | `0b1111_0000` |
| 字节 (仅限于 `u8`) | `b'A'`        |

**整形默认是`i32`**

超出了表示范围时会发生整型溢出，在debug版本会检查整型溢出（how？？这需要运行时进行啊）如果发现存在，则会报panic退出，panic实际上就是运行时的操作。在release版本不会进行检查，如果溢出会进行two's complement srapping二进制补码包裹（比如255上限时对应256会溢出成0，类似一个循环队列）

##### 浮点类型

`rust`中的浮点类型有`f32`和`f64` 两类，默认为`f64`，因为速度与`f32`几乎相同，但精度更高，所有浮点数都有符号

采用`IEEE-754`标准，`f32`是单精度浮点型`f64`是双精度浮点型

##### 数字运算

支持加减乘除取模，且整数除法向下取整

##### 布尔类型

`bool`大小1Byte，取值`true`和`false`

##### 字符类型

`char`  跟cpp类似，字符用单印号，字符串用双引号

`rust`的字符类型大小为4Byte，采用Unicode标量，一个字节可以容纳范围远超ASCII，比如可以放下emoji 😎

##### 复合类型

复合类型指的是把多个值组合成一个类型。`rust`两种基本的符合类型是元组和数组

###### 元组

多种类型的多个值放到一个复合类型中，**长度固定**，语法是在小括号中用逗号间隔

如`let tup: (i32, f64, u8) = (500, 6.4, 1)`

想要从元组中取值需要使用模式匹配来解构（类似python写法）

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```

也可以按顺序用索引加`.`取得，下标从**0**开始，如取`f64`类型的元素应该使用`tup.1`

空元组是一种特殊类型，也写成`()`，被称为**单元类型**，该值被称为**单元值**。如果表达式部返回任何其他值，就**隐式返回单元值**



###### 数组

数组中每个元素必须有相同类型，且`rust`中的数组也是**定长**的，使用方法是在方括号中用逗号分割定义。如`let a = [1, 2, 3, 4]`

数组一般用于需要将数据分配到**栈而非堆**时，`rust`中也有`vector`，应优先使用`vector`

也可以显式指定类型和长度定义数组，如`let a: [i32; 5] = [1, 2, 3, 4, 5]`

如果数组中每个元素都相同，可以直接值和个数定义，如`let a = [3; 5]`定义了5个3组成的数组（着一块和matlab语法很像。

数组的元素访问用`[]`

在运行时访问超出范围的值时会`panic`而不是像C一样稀里糊涂运行着。



### 函数

`main`函数是程序入口点，`rust`中函数使用下划线命名法，即所有字母都是小写的并且用下划线来分割单词。`rust`不在意函数定义位置，只要定义过就行。

函数必须声明每个参数的类型(类似c/cpp)，多个参数时用逗号分隔。

#### 语句和表达式

函数体由一系列语句组成，但也可以选择用表达式结尾。`rust`是一门特别的**基于表达式**的语言，选择语句或者表达式将会影响到函数体。

**语句**(statement)执行操作但不返回值。如`let y = 6;`

**表达式**(expression)计算并产生一个值，语句中的一部分也可以是表达式，比如上面的`6`就是一个表达式。函数**调用**是表达式，宏调用也是表达式，创建新作用域的大括号`{}`也是表达式

函数**定义**本身也是语句。和c赋值语句不同，语句没有返回值，所以不能写连等如`let x = (let y = 6);`



表达式的结尾没有分号。如果在表达式末尾加上分号，就会转换为不会返回值的语句

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1   // 没有;
    };

    println!("The value of y is: {}", y);
}
```

如其中y后的那一串`{}`里的就是表达式

#### 带返回值的函数

`rust`不像c一样写显式返回值，默认可以用隐式返回最后一个表达式的值，如果用`return`关键字和指定值，可以从函数提前返回。函数返回值的类型写在参数列表后用 `->`接类型表示。

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
```

如果带上分号，会让函数从表达式变成语句，没有返回值（即会返回一个空元组类型表示没有返回值），导致类型和i32不匹配报错。



### 注释

`rust`通用注释是`//`，还有一种文档注释留待之后再说。



### 控制流

#### if表达式

if else用法类似c中，但是if后必须是一个`bool`类型的表达式，`rust`不会自动把非布尔值转换成布尔值。

在多个if串else if中会检测第一个为真的if条件执行

##### let中使用if

类似于cpp中的三目运算符 ?:

如

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
```

if表达式在if分支和else分支的结果必须是相同类型，不匹配的话会报错。

#### 循环

`rust`有三种循环，`loop` `while` `for`

##### loop

无条件循环，可用continue和break跳出，使用时可以带上循环标签（`loop label`）配合使用来跳出指定的循环而非默认的内层循环

```rust
// 无控制loop
fn main() {
    loop {
        println!("again!");
    }
}
```

```rust
// 带控制loop
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
```

##### while

用法类似c，不过条件不用打括号，且必须为`bool`类型

##### for

`rust`中的for循环可以实现类似`python`中用法，主要用于遍历时有效避免`panic`

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }
}
```

一个反转区间倒计时的例子

```rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
```

以上代码中rev是反转方法。



## Char4 所有权

