# `rust`权威指南读书笔记

[TOC]

## Char3

### 变量与可变性

#### 变量

用let声明的变量默认是不可变的，如以下会报错

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

如果想要改变值的话，需要声明时加上`mut`

`let mut x = 5;`

#### 常量

`const`关键字，不允许使用`mut`也不能修改值，只能设置为**常量表达式**，且**类型必须注明**，也不能使用函数调用结果或者运行时结果

常量命名应该用全大写加下划线，如下:

`const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;`

#### 遮蔽

可以用`let`重复使用相同的变量名来遮蔽变量，如

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```

外层作用域里遮蔽一次，内层作用域里遮蔽一次，但传不出来，所以两次输出结果应该是12和6

遮蔽可以完成一些值的转换，但完成之后还是不可变的

与`mut`的区别，用`let`本质是再创建了一个新的变量，但是重复使用了相同的名称，因此用`let`遮蔽可以同名换类型，但`mut`不允许更改类型，如

```rust
fn main() {
    let spaces = "   ";
    let spaces = spaces.len();
}
```

```rust
fn main() {
    let mut spaces = "   ";
    spaces = spaces.len();
}
```

第一个ok第二个报错。

### 数据类型

`rust`是静态类型语言，即需要在编译器而非运行时得到所有的变量类型

#### 标量类型

表示单个值的类型（scalar），在`rust`中有整型、浮点、布尔和字符四种

 ##### 整型

| 长度   | 有符号类型 | 无符号类型 |
| ------ | ---------- | ---------- |
| 8 位   | `i8`       | `u8`       |
| 16 位  | `i16`      | `u16`      |
| 32 位  | `i32`      | `u32`      |
| 64 位  | `i64`      | `u64`      |
| 128 位 | `i128`     | `u128`     |
| arch   | `isize`    | `usize`    |

`isize`和`usize`取决于系统架构，64位则是64位，32位则32位

可能属于多个数字类型的数字字面值允许使用类型后缀指定类型，如`58u8`。数字字面值还可以用`_`作为不影响大小和正确性的可视分割符，如`1_000`

不同进制还可以直接用于字面量赋值

| 数字字面量         | 示例          |
| ------------------ | ------------- |
| 十进制             | `98_222`      |
| 十六进制           | `0xff`        |
| 八进制             | `0o77`        |
| 二进制             | `0b1111_0000` |
| 字节 (仅限于 `u8`) | `b'A'`        |

**整形默认是`i32`**

超出了表示范围时会发生整型溢出，在debug版本会检查整型溢出（how？？这需要运行时进行啊）如果发现存在，则会报panic退出，panic实际上就是运行时的操作。在release版本不会进行检查，如果溢出会进行two's complement srapping二进制补码包裹（比如255上限时对应256会溢出成0，类似一个循环队列）

##### 浮点类型

`rust`中的浮点类型有`f32`和`f64` 两类，默认为`f64`，因为速度与`f32`几乎相同，但精度更高，所有浮点数都有符号

采用`IEEE-754`标准，`f32`是单精度浮点型`f64`是双精度浮点型

##### 数字运算

支持加减乘除取模，且整数除法向下取整

##### 布尔类型

`bool`大小1Byte，取值`true`和`false`

##### 字符类型

`char`  跟cpp类似，字符用单印号，字符串用双引号

`rust`的字符类型大小为4Byte，采用Unicode标量，一个字节可以容纳范围远超ASCII，比如可以放下emoji 😎

##### 复合类型

复合类型指的是把多个值组合成一个类型。`rust`两种基本的符合类型是元组和数组

###### 元组

多种类型的多个值放到一个复合类型中，**长度固定**，语法是在小括号中用逗号间隔

如`let tup: (i32, f64, u8) = (500, 6.4, 1)`

想要从元组中取值需要使用模式匹配来解构（类似python写法）

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```

也可以按顺序用索引加`.`取得，下标从**0**开始，如取`f64`类型的元素应该使用`tup.1`

空元组是一种特殊类型，也写成`()`，被称为**单元类型**，该值被称为**单元值**。如果表达式部返回任何其他值，就**隐式返回单元值**



###### 数组

数组中每个元素必须有相同类型，且`rust`中的数组也是**定长**的，使用方法是在方括号中用逗号分割定义。如`let a = [1, 2, 3, 4]`

数组一般用于需要将数据分配到**栈而非堆**时，`rust`中也有`vector`，应优先使用`vector`

也可以显式指定类型和长度定义数组，如`let a: [i32; 5] = [1, 2, 3, 4, 5]`

如果数组中每个元素都相同，可以直接值和个数定义，如`let a = [3; 5]`定义了5个3组成的数组（着一块和matlab语法很像。

数组的元素访问用`[]`

在运行时访问超出范围的值时会`panic`而不是像C一样稀里糊涂运行着。



### 函数

`main`函数是程序入口点，`rust`中函数使用下划线命名法，即所有字母都是小写的并且用下划线来分割单词。`rust`不在意函数定义位置，只要定义过就行。

函数必须声明每个参数的类型(类似c/cpp)，多个参数时用逗号分隔。

#### 语句和表达式

函数体由一系列语句组成，但也可以选择用表达式结尾。`rust`是一门特别的基于表达式的语言，选择语句或者表达式将会影响到函数体。

**语句**(statement)

**表达式**(expression)
